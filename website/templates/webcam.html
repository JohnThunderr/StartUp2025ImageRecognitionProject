{% extends "base.html" %}
{% block title %}Webcam{% endblock %}

{% block content %}
<div class="max-w-3xl mx-auto bg-white p-8 rounded-lg shadow-md text-center">
  <h1 class="text-2xl font-bold mb-4">Webcam</h1>
  <p class="text-gray-700 mb-6">
    Close this page to stop the stream. <br />
    If it doesn’t start, make sure your camera isn’t in use by another app.
  </p>

  <div style="position: relative; display: inline-block;">
    <img id="video" src="{{ url_for('views.video_feed') }}" width="640" height="480" class="rounded-lg shadow-md border border-gray-300"/>
    <canvas id="overlay" width="640" height="480" style="position: absolute; top: 0; left: 0;"></canvas>
  </div>
</div>

<script>
const canvas = document.getElementById("overlay");
const ctx = canvas.getContext("2d");
let currentTrees = [];
const BUTTON_WIDTH = 50;
const BUTTON_HEIGHT = 20;
const BUTTON_MARGIN = 5;

// Fetch detections every 200ms
async function fetchDetections() {
    try {
        const res = await fetch("/detections");
        const data = await res.json();
        currentTrees = data.trees;
        drawOverlay();
    } catch (err) {
        console.error("Error fetching detections:", err);
    }
}

// Draw boxes and buttons
function drawOverlay() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    currentTrees.forEach(tree => {
        const { id, x, y, w, h } = tree;

        // Box
        ctx.strokeStyle = "lime";
        ctx.lineWidth = 2;
        ctx.strokeRect(x, y, w, h);

        // Label
        ctx.fillStyle = "lime";
        ctx.font = "14px Arial";
        ctx.fillText(id, x, y - 5);

        // Cut button
        ctx.fillStyle = "red";
        ctx.fillRect(x, y + h + BUTTON_MARGIN, BUTTON_WIDTH, BUTTON_HEIGHT);
        ctx.fillStyle = "white";
        ctx.fillText("Cut", x + 5, y + h + BUTTON_MARGIN + 15);

        // Not Cut button
        ctx.fillStyle = "green";
        ctx.fillRect(x + BUTTON_WIDTH + BUTTON_MARGIN, y + h + BUTTON_MARGIN, BUTTON_WIDTH, BUTTON_HEIGHT);
        ctx.fillStyle = "white";
        ctx.fillText("Not Cut", x + BUTTON_WIDTH + BUTTON_MARGIN + 2, y + h + BUTTON_MARGIN + 15);

        // Save button coordinates
        tree.cutBtn = { x: x, y: y + h + BUTTON_MARGIN, w: BUTTON_WIDTH, h: BUTTON_HEIGHT };
        tree.notCutBtn = { x: x + BUTTON_WIDTH + BUTTON_MARGIN, y: y + h + BUTTON_MARGIN, w: BUTTON_WIDTH, h: BUTTON_HEIGHT };
    });
}

// Handle clicks
canvas.addEventListener("click", function(event) {
    const rect = canvas.getBoundingClientRect();
    const mouseX = event.clientX - rect.left;
    const mouseY = event.clientY - rect.top;

    currentTrees.forEach(tree => {
        if (mouseX >= tree.cutBtn.x && mouseX <= tree.cutBtn.x + tree.cutBtn.w &&
            mouseY >= tree.cutBtn.y && mouseY <= tree.cutBtn.y + tree.cutBtn.h) {
            sendDecision(tree.id, "cut");
        }
        if (mouseX >= tree.notCutBtn.x && mouseX <= tree.notCutBtn.x + tree.notCutBtn.w &&
            mouseY >= tree.notCutBtn.y && mouseY <= tree.notCutBtn.y + tree.notCutBtn.h) {
            sendDecision(tree.id, "not_cut");
        }
    });
});

// Send decision to Flask
function sendDecision(treeId, decision) {
    fetch("/decision", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ tree_id: treeId, decision: decision })
    })
    .then(res => res.json())
    .then(data => console.log(`Tree ${treeId} marked as ${decision}`));
}

// Start polling
setInterval(fetchDetections, 200);

// Optional: Release webcam when leaving page
window.addEventListener("beforeunload", function() {
    fetch("/webcam/stop");
});
</script>
{% endblock %}
